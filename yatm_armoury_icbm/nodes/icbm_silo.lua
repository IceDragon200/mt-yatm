--
-- ICBM Silo nodes
-- These are nodes that make up the ICBM assembly
-- The key component is just the silo node though, the guiding rings are decorative for now,
-- and are safe to use on regular builds.
--
-- The Silo has a different data behaviour from those in the data logic series of nodes.
-- While those allowed configuring ports per direction, the silo node has multiple ports for different functions
-- And ignores the origin and destination direction for it's receives and emits.
-- This simplifies the interface a bit.
--
local data_network = assert(yatm.data_network)

-- Deadzone
--   The Silo has a deadzone of up to 8 nodes in any direction, this it to prevent it from blowing itself up with a misconfigured ICBM.
--
-- Required Input Ports:
--   Launch Port - port which commands the silo to launch the icbm to specified offset.
--   Arming Port - port which commands the silo to arm the ICBM, this will consume items in the warhead and shell slots
--   Probing Port - port which asks the silo to report it's current status
--   Offset X Port - The relative X position from the silo to launch the ICBM
--   Offset Y Port - The relative Y position from the silo to launch the ICBM
--   Offset Z Port - The relative Z position from the silo to launch the ICBM
--
-- Optional Output Ports:
--   Error Port - any errors that are generated by the silo are sent to this port
--   Launched Port - port which reports when an ICBM is launched
--   Armed Port - port which reports when an ICBM has been armed
--
-- Values:
--   Launch Code - the launch code is a string of any length that must be matched before an ICBM can be launched
--   Offset X - little-endian i16 (signed 16 bit integer) string representing the X-coord offset from the silo position
--   Offset Y - little-endian i16 (signed 16 bit integer) string representing the Y-coord offset from the silo position
--   Offset Z - little-endian i16 (signed 16 bit integer) string representing the Z-coord offset from the silo position

local ProbeSchema =
  yatm.BinSchema:new("icbm_silo.probe", {
    {"offset_x", "i16"},
    {"offset_y", "i16"},
    {"offset_z", "i16"},
    {"status", "i16"},
  })

local data_interface = {
  on_load = function (self, pos, node)
    yatm_data_logic.mark_all_inputs_for_active_receive(pos)
  end,

  receive_pdu = function (self, pos, node, dir, port, value)
    local meta = minetest.get_meta(pos)

    local blob = yatm_core.string_hex_unescape(value)

    if port == meta:get_int("launch_port") then
      --
      local launch_code = meta:get_string("launch_code")
      if yatm_core.string_hex_unescape(launch_code) == blob then
        -- TODO: launch ICBM
      end
    elseif port == meta:get_int("arming_port") then
      --
      -- TODO: arm ICBM
    elseif port == meta:get_int("probing_port") then
      -- Probing asks that the silo report it's current status on it's probe port
      -- This 'probe' packet includes the currently set offsets and a status flag
      local probe_packet =
        ProbeSchema:write({
          offset_x = meta:get_int("offset_x"),
          offset_y = meta:get_int("offset_y"),
          offset_z = meta:get_int("offset_z"),
          status = 0, -- FIXME: proper status codes
        })

      yatm_data_logic.emit_value(pos, meta:get_int("probe_port"), probe_packet)
    elseif port == meta:get_int("offset_x_port") then
      --
      local offset_value = yatm.ByteDecoder.d_i16(value)
      meta:set_int("offset_x", offset_value)
    elseif port == meta:get_int("offset_y_port") then
      --
      local offset_value = yatm.ByteDecoder.d_i16(value)
      meta:set_int("offset_y", offset_value)
    elseif port == meta:get_int("offset_z_port") then
      --
      local offset_value = yatm.ByteDecoder.d_i16(value)
      meta:set_int("offset_z", offset_value)
    end

    --meta:get_int("error_port")
    --meta:get_int("launched_port")
    --meta:get_int("armed_port")
  end,

  get_programmer_formspec = function (self, pos, user, pointed_thing, assigns)
    --
    local meta = minetest.get_meta(pos)

    assigns.tab = assigns.tab or 1

    local fe = minetest.formspec_escape

    local formspec =
      "size[8,9]" ..
      yatm.formspec_bg_for_player(user:get_player_name(), "data") ..
      "tabheader[0,0;tab;Ports,Data;" .. assigns.tab .. "]"

    if assigns.tab == 1 then
      formspec =
        formspec ..
        "label[0,0;Port Configuration]"

      formspec =
        formspec ..
        "label[0,1;Inputs]" ..
        "field[0.25,2;4,1;offset_x_port;X-offset Port;" .. fe(meta:get_int("offset_x_port")) .. "]" ..
        "field[0.25,3;4,1;offset_y_port;Y-offset Port;" .. fe(meta:get_int("offset_y_port")) .. "]" ..
        "field[0.25,4;4,1;offset_z_port;Z-offset Port;" .. fe(meta:get_int("offset_z_port")) .. "]" ..
        "field[4.25,5;4,1;launch_port;Launch Port;" .. fe(meta:get_int("launch_port")) .. "]" ..
        "field[4.25,6;4,1;arming_port;Arming Port;" .. fe(meta:get_int("arming_port")) .. "]" ..
        "field[4.25,7;4,1;probing_port;Probing Port;" .. fe(meta:get_int("probing_port")) .. "]" ..
        "label[4,1;Outputs]" ..
        "field[0.25,2;4,1;error_port;Error Port;" .. fe(meta:get_int("error_port")) .. "]" ..
        "field[0.25,3;4,1;launched_port;Launched Port;" .. fe(meta:get_int("launched_port")) .. "]" ..
        "field[0.25,4;4,1;armed_port;Armed Port;" .. fe(meta:get_int("armed_port")) .. "]" ..
        ""

    elseif assigns.tab == 2 then
      formspec =
        formspec ..
        "label[0,0;Data Configuration]" ..
        "label[0,1;Codes]" ..
        "field[0.25,2;8,1;launch_code;Launch Code;" .. fe(meta:get_string("launch_code")) .. "]"
    end

    return formspec
  end,

  receive_programmer_fields = function (self, player, form_name, fields, assigns)
    local meta = minetest.get_meta(assigns.pos)
  end,
}

local function get_formspec_name(pos)
  return "yatm_armoury_icbm:icbm_silo:" .. yatm.vector3.to_string(pos)
end

local function get_formspec(pos, user, assigns)
  local meta = minetest.get_meta(pos)
  local inv = meta:get_inventory()

  local spos = pos.x .. "," .. pos.y .. "," .. pos.z

  local formspec =
    "size[8,9]" ..
    yatm.formspec_bg_for_player(user:get_player_name(), "machine_radioactive") ..
    "label[0,0;Shell]" ..
    "list[nodemeta:" .. spos .. ";shell_slot;0,1.3;1,1;]" ..
    "label[4,0;Warhead]" ..
    "list[nodemeta:" .. spos .. ";warhead_slot;4,1.3;1,1;]"

  if inv:get_size("capsule_inv") > 0 then
    formspec =
      formspec ..
      "label[0,2.5;Capsule]" ..
      "list[nodemeta:" .. spos .. ";capsule_inv;0,3.3;8,2;]" ..
      "listring[nodemeta:" .. spos .. ";capsule_inv]" ..
      "listring[current_player;main]"
  end

  formspec =
    formspec ..
    "list[current_player;main;0,4.85;8,1;]" ..
    "list[current_player;main;0,6.08;8,3;8]" ..
    "listring[nodemeta:" .. spos .. ";shell_slot]" ..
    "listring[current_player;main]" ..
    "listring[nodemeta:" .. spos .. ";warhead_slot]" ..
    "listring[current_player;main]" ..
    default.get_hotbar_bg(0,4.85)

  return formspec
end

function receive_fields(user, form_name, fields, assigns)
  if fields["arm"] then
    -- create an ICBM
  elseif fields["disarm"] then
    -- remove armed ICBM
  end
  return true
end

local function refresh_formspec(pos, player)
  minetest.after(0, function ()
    yatm_core.refresh_player_formspec(player, get_formspec_name(pos), function (ply, assigns)
      return get_drive_case_formspec(assigns.pos, ply, assigns)
    end)
  end)
end

local groups = {
  cracky = 1,
  data_interface_in = 1,
  data_interface_out = 1,
}

-- Optional fluid interface
local fluid_interface
if yatm_fluids then
  groups.fluid_interface_in = 1

  local FluidInterface = assert(yatm.fluids.FluidInterface)

  fluid_interface =
    FluidInterface.new_simple("tank", 4000)

  -- TODO: add hooks to refresh timer
end

-- Optional item interface
local item_interface
if yatm_item_storage then
  groups.item_interface_in = 1

  local ItemInterface = assert(yatm.items.ItemInterface)

  item_interface =
    ItemInterface.new_directional(function (self, pos, dir)
      local node = minetest.get_node(pos)
      local new_dir = yatm_core.facedir_to_face(node.param2, dir)

      if new_dir == yatm_core.D_DOWN then
        -- load shells from the bottom
        return "shell_slot"
      elseif new_dir == yatm_core.D_UP then
        -- Can't load anything from the top
        return nil, "cannot interact with top of node"
      else
        -- load warheads from anywhere else
        -- this allows you to use the other directions for cables or fluids
        return "warhead_slot"
      end
    end)

  -- TODO: add hooks to refresh timer
end

local function refresh_infotext(pos, node)
  local meta = minetest.get_meta(pos)
  local offset_x = meta:get_int("offset_x")
  local offset_y = meta:get_int("offset_y")
  local offset_z = meta:get_int("offset_z")

  local infotext =
    "ICBM Silo\n" ..
    "Offset: " .. yatm.vector3.to_string(yatm.vector3.new(offset_x, offset_y, offset_z)) .. "\n"

  if fluid_interface then
    -- has fluid interface
    infotext =
      infotext ..
      "Tank: " .. yatm.fluids.FluidMeta.to_infotext(meta, "tank", fluid_interface.capacity) .. "\n"
  end

  if item_interface then
    -- has item interface
    -- nothing to do currently
  end

  meta:set_string("infotext", infotext)
end

function allow_metadata_inventory_move(pos, from_list, from_index, to_list, to_index, count, player)
  if to_list == "warhead_slot" then
    -- FIXME: ensure that origin item is a warhead
  elseif to_list == "shell_slot" then
    -- FIXME: ensure that origin item is a shell
  elseif to_list == "capsule_inv" then
    return 1
  else
    return 0
  end
end

function allow_metadata_inventory_put(pos, listname, index, stack, player)
end

function allow_metadata_inventory_take(pos, listname, index, stack, player)
end

function on_metadata_inventory_move(pos, from_list, from_index, to_list, to_index, count, player)
end

function on_metadata_inventory_put(pos, listname, index, stack, player)
end

function on_metadata_inventory_take(pos, listname, index, stack, player)
end

minetest.register_node("yatm_armoury_icbm:icbm_silo", {
  description = "ICBM Silo",

  groups = groups,

  tiles = {
    "yatm_icbm_silo_top.png",
    "yatm_icbm_silo_bottom.png",
    "yatm_icbm_silo_side.png",
    "yatm_icbm_silo_side.png",
    "yatm_icbm_silo_side.png",
    "yatm_icbm_silo_side.png",
  },

  paramtype = "light",
  paramtype2 = "facedir",

  sounds = default.node_sound_metal_defaults(),

  drawtype = "nodebox",
  node_box = {
    type = "fixed",
    fixed = {
      {-0.5, -0.5, -0.5, 0.5, 0.5, 0.5},
    },
  },

  on_construct = function (pos)
    local meta = minetest.get_meta(pos)
    local inv = meta:get_inventory()

    inv:set_size("warhead_slot", 1)
    inv:set_size("shell_slot", 1)

    meta:set_int("offset_x", 0)
    meta:set_int("offset_y", 0)
    meta:set_int("offset_z", 0)

    minetest.add_entity(vector.add(pos, yatm_core.V3_UP), "yatm_armoury_icbm:icbm")
  end,

  data_network_device = {
    type = "device",
  },
  data_interface = data_interface,

  item_interface = item_interface,
  fluid_interface = fluid_interface,

  on_rightclick = function (pos, node, user, item_stack, pointed_thing)
    local assigns = { pos = pos, node = node }
    local formspec = get_formspec(pos, user, assigns)
    local formspec_name = get_formspec_name(pos)

    yatm_core.bind_on_player_receive_fields(user, formspec_name,
                                            assigns,
                                            receive_fields)

    minetest.show_formspec(
      user:get_player_name(),
      formspec_name,
      formspec
    )
  end,

  refresh_infotext = refresh_infotext,
})

local node_box = {
  type = "fixed",
  fixed = {
    yatm.Cuboid:new( 0,  2,  0, 15,  4,  1):fast_node_box(),
    yatm.Cuboid:new( 0, 10,  0, 15,  4,  1):fast_node_box(),

    yatm.Cuboid:new(15,  2,  0,  1,  4, 15):fast_node_box(),
    yatm.Cuboid:new(15, 10,  0,  1,  4, 15):fast_node_box(),

    yatm.Cuboid:new( 1,  2, 15, 15,  4,  1):fast_node_box(),
    yatm.Cuboid:new( 1, 10, 15, 15,  4,  1):fast_node_box(),

    yatm.Cuboid:new( 0,  2,  1,  1,  4, 15):fast_node_box(),
    yatm.Cuboid:new( 0, 10,  1,  1,  4, 15):fast_node_box(),
  },
}

minetest.register_node("yatm_armoury_icbm:icbm_guiding_ring", {
  description = "ICBM Guiding Ring",

  groups = {
    cracky = 1,
  },

  tiles = {
    "yatm_icbm_guiding_ring_top.png",
    "yatm_icbm_guiding_ring_bottom.png",
    "yatm_icbm_guiding_ring_side.png",
    "yatm_icbm_guiding_ring_side.png",
    "yatm_icbm_guiding_ring_side.png",
    "yatm_icbm_guiding_ring_side.png",
  },

  paramtype = "light",
  paramtype2 = "facedir",

  sounds = default.node_sound_metal_defaults(),

  drawtype = "nodebox",
  node_box = node_box,

  is_ground_content = false,
  sunlight_propagates = true,
})

minetest.register_node("yatm_armoury_icbm:icbm_guiding_ring_warning_strips", {
  description = "ICBM Guiding Ring [Warning Strips]",

  groups = {
    cracky = 1,
  },

  tiles = {
    "yatm_icbm_guiding_ring_top.png",
    "yatm_icbm_guiding_ring_bottom.png",
    "yatm_icbm_guiding_ring_warning_side.png",
    "yatm_icbm_guiding_ring_warning_side.png",
    "yatm_icbm_guiding_ring_warning_side.png",
    "yatm_icbm_guiding_ring_warning_side.png",
  },

  paramtype = "light",
  paramtype2 = "facedir",

  sounds = default.node_sound_metal_defaults(),

  drawtype = "nodebox",
  node_box = node_box,

  is_ground_content = false,
  sunlight_propagates = true,
})
